# ゴロムテーブル動的リビルド手法の再検討

## 現行実装の整理
- タイル全体の探索で選ばれた残差を `entropy_values` に蓄積しつつ、行・バケットごとにビット長コストを `bucket_costs` へ累積している。各サンプルについて全ての `k` (列) を試算し、`reduce_a(a)` のバケット単位で `q + 1 + k` を足し込む仕様である。 【F:src/tlg8_encode.cpp†L345-L606】【F:src/tlg8_encode.cpp†L51-L108】
- 上記のコスト行列に対して `optimize_row_from_cost` が DP で各列の割当数を決め、推定ビット数とテーブル書き出し 594bit のオーバーヘッドを比較したうえでテーブル更新を採否している。 【F:src/tlg8_encode.cpp†L610-L661】
- 既存テーブルを正規化し直す補助関数として `normalize_histogram_row`／`rebuild_golomb_table_from_histogram` が用意されており、ヒストグラムから 1024 スロットへの再分配が可能になっている。 【F:src/tlg8_entropy.cpp†L134-L198】【F:src/tlg8_entropy.cpp†L866-L886】

## 現行手法の懸念点
1. **計算コストが高い**: 各残差サンプルに対して 9 列すべての `k` を評価し、`bucket_costs` に蓄積しているため、8×8 ブロック全体で `サンプル数 × 9` 回の除算／シフトが走る。タイル全面を探索する現状のループと組み合わせると計測のオーバーヘッドが大きく、実運用でのエンコード時間を悪化させる懸念がある。 【F:src/tlg8_encode.cpp†L51-L108】【F:src/tlg8_encode.cpp†L395-L606】
2. **統計のばらつきに弱い**: `sample_counts[row] > 0` なら無条件で DP 結果を採用し、最後に総ビット数と 594bit の固定オーバーヘッドだけでロールバック判定している。サンプルが数十件しかない行でも列配分が大きく揺れ、全体としては改善しても一部の行で悪化するケースが観測された。行単位での尤度差や正則化が欠如している。 【F:src/tlg8_encode.cpp†L621-L647】
3. **インターリーブ行の扱いが粗い**: インターリーブ時は全コンポーネントの値を行 0/3 に強制的にまとめており、実際には行 1,2,4,5 に割り振った方が有利なケースを検証できていない。インターリーブで増幅した成分を単一行に押し込むことで、他行との分離が阻害され DP の自由度が減っている。 【F:src/tlg8_encode.cpp†L552-L605】
4. **テーブル送信コストが固定**: テーブルを更新するたびに 6×9×11 = 594bit を送出しており、タイル単位の改善量が数百ビット程度だと全体で逆効果になる。現状は「全テーブル送るか送らないか」の二択であり、部分更新や差分符号化の検討余地がある。 【F:src/tlg8_encode.cpp†L638-L661】

## 改善案
1. **ヒストグラム直接法への置き換え**: 残差の mapped 値と `reduce_a(a)` のバケット番号をヒストグラム化し、`normalize_histogram_row` で行ごとに 1024 スロットへ再配分するアプローチを採用する。`bucket_costs` の全列試算を省けるため計算量が大幅に減り、既存の `rebuild_golomb_table_from_histogram` を再利用できる。サンプルが少ない行は既定行列をそのまま残す、あるいはヒストグラムを平滑化することで過学習を抑制できる。 【F:src/tlg8_entropy.cpp†L134-L198】【F:src/tlg8_entropy.cpp†L866-L886】
2. **行単位の更新判定と正則化**: DP の採用可否を全体一括ではなく行ごとに評価し、各行でのビット削減量から「その行に割り当てられた 9×11bit の符号化コスト」を差し引いて判断する。さらに、`sample_counts[row]` がしきい値を下回る場合は既定値との線形補間を行い、統計のばらつきによる暴走を防ぐ。これにより改善が見込める行だけ部分的にテーブルを更新し、総オーバーヘッドを削減できる。 【F:src/tlg8_encode.cpp†L621-L647】
3. **インターリーブ分配の拡張**: インターリーブ適用時にもコンポーネントごとの最適行を評価し、`bucket_costs` を行別に蓄積する。現在の実装では行 0/3 へ固定されるため、DP が探索できるテーブル候補が限定されている。行選択まで最適化すれば、各行の統計特性に合った `k` 分布を得られる可能性が高い。 【F:src/tlg8_encode.cpp†L552-L605】
4. **テーブル差分送信**: 連続する列の変化量が小さい場合は RLE や差分符号化で 594bit より短く表現できる。更新行のみを対象にした可変長符号化（例: 変更行マスク + その行の列数 9 個を delta 符号化）を導入すれば、動的テーブルを頻繁に切り替えてもビットコストが抑えられる。これは上記の行単位更新と相性が良い。 【F:src/tlg8_encode.cpp†L638-L661】

これらの改良案を組み合わせることで、現行アルゴリズムの計算量と安定性の課題を緩和しつつ、圧縮率向上を狙える見込みがある。
